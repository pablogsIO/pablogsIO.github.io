<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Pablo Garcia</title><description>Apps for iPhone, iPad, Apple TV and Apple Watch</description><link>https://pablogs.io</link><language>en</language><lastBuildDate>Sat, 23 Jan 2021 08:16:58 +0100</lastBuildDate><pubDate>Sat, 23 Jan 2021 08:16:58 +0100</pubDate><ttl>250</ttl><atom:link href="https://pablogs.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://pablogs.io/blog/2019-07-31-Spritekit-BackgroundScrollPartThree</guid><title>Spritekit - Background Scrolling - III</title><description>In this final post we will add speed to the background movement. When we will press the screen, we will increase the speed of the background, and if we stop pressing the screen, the speed will decrease to zero.</description><link>https://pablogs.io/blog/2019-07-31-Spritekit-BackgroundScrollPartThree</link><pubDate>Wed, 31 Jul 2019 08:00:00 +0200</pubDate><content:encoded><![CDATA[<p>In this final post we will add speed to the background movement. When we will press the screen, we will increase the speed of the background, and if we stop pressing the screen, the speed will decrease to zero.</p><p>This will be the result:</p><p align="center">
  <img width="400" src="https://pablogs.io/images/posts/spritekit/backgroundscroll/spritekit3.gif">
</p><h3>Gesture recognizer</h3><p>We need to know when the user is pressing the screen, so in the didMove function, we have added a UILongPressGestureRecognizer var and added to the scene's view.</p><pre><code><span class="keyword">override func</span> didMove(to view: <span class="type">SKView</span>) {

        <span class="keyword">let</span> longPressGR = <span class="type">UILongPressGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="keyword">#selector</span>(<span class="call">longPress</span>(sender:)))
        longPressGR.<span class="property">delegate</span> = <span class="keyword">self</span>
        longPressGR.<span class="property">minimumPressDuration</span> = <span class="number">0.1</span>
        <span class="keyword">self</span>.<span class="property">view</span>?.<span class="call">addGestureRecognizer</span>(longPressGR)

        speedLabel = <span class="type">SKLabelNode</span>(fontNamed: <span class="string">"Chalkduster"</span>)
        speedLabel.<span class="property">fontSize</span> = <span class="number">50</span>
        speedLabel.<span class="property">text</span> = <span class="string">"0.0"</span>
        speedLabel.<span class="property">horizontalAlignmentMode</span> = .<span class="dotAccess">right</span>
        speedLabel.<span class="property">position</span> = <span class="type">CGPoint</span>(x: <span class="number">400</span>, y: <span class="number">700</span>)
        <span class="call">addChild</span>(speedLabel)
    }

</code></pre><h3>update function</h3><p>We have changed the update function of the BackgroundScroll class, adding a new boolean parameter to tell the backgroundScroll if he has to increase (or not) the background speed.</p><pre><code>

<span class="keyword">public func</span> update(deltaTime: <span class="type">TimeInterval</span>, increaseVelocity: <span class="type">Bool</span>)

</code></pre><p>And that's all folks!!</p><p>You have the code <a href="https://github.com/pablogsIO/pablogsIO.github.io/tree/master/sourcecode/spritekit/BackgroundScrollPartThree">here</a>. Hope you enjoy it!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://pablogs.io/blog/2019-06-30-Spritekit-BackgroundScrollPartTwo</guid><title>Spritekit - Background Scrolling - II</title><description>So, once we've achieved background scrolling (to the right), we are going to move forward and do this:</description><link>https://pablogs.io/blog/2019-06-30-Spritekit-BackgroundScrollPartTwo</link><pubDate>Sun, 30 Jun 2019 08:00:00 +0200</pubDate><content:encoded><![CDATA[<p>So, once we've achieved background scrolling (to the right), we are going to move forward and do this:</p><ul><li>Detect when the user touch the right/left side of the screen</li><li>Update nodes in the linkedlist</li></ul><p>Once we achieve this, we'd have something like this:</p><p align="center">
  <img width="200" src="https://pablogs.io/images/posts/spritekit/backgroundscroll/left.gif">
</p><h3>Screen touch</h3><ul><li>We have to override touchesBegan function and locate where the user has touched the screen.</li></ul><pre><code><span class="keyword">extension</span> <span class="type">MainScene</span>: <span class="type">UIGestureRecognizerDelegate</span> {

    <span class="keyword">override func</span> touchesBegan(<span class="keyword">_</span> touches: <span class="type">Set</span>&lt;<span class="type">UITouch</span>&gt;, with event: <span class="type">UIEvent</span>?) {

        <span class="keyword">for</span> touch <span class="keyword">in</span> touches {
            <span class="keyword">let</span> position = touch.<span class="call">location</span>(in: <span class="keyword">self</span>)

            <span class="keyword">if</span> position.<span class="property">x</span> &lt; <span class="keyword">self</span>.<span class="property">frame</span>.<span class="property">width</span>/<span class="number">2</span> {
                <span class="keyword">self</span>.<span class="property">backgroundScroll</span>?.<span class="call">changeDirection</span>(direction: .<span class="dotAccess">left</span>)
            } <span class="keyword">else</span> {
                <span class="keyword">self</span>.<span class="property">backgroundScroll</span>?.<span class="call">changeDirection</span>(direction: .<span class="dotAccess">right</span>)
            }
        }

    }
}
</code></pre><h3>Update nodes in the linkedlist</h3><ul><li>We have modified our update function to change the position of all nodes in the LinkedList. Depending on scroll direction, we'll take the head or the tail of the linkedlist and update all node's positions.</li></ul><pre><code><span class="keyword">public func</span> update(deltaTime: <span class="type">TimeInterval</span>) {

    <span class="keyword">guard</span> !linkedBackgrounds.<span class="property">isEmpty</span> <span class="keyword">else</span> {
        <span class="keyword">return</span>
    }

    <span class="keyword">if</span> direction == .<span class="dotAccess">right</span> {
        <span class="keyword">if let</span> head = linkedBackgrounds.<span class="property">first</span> {
            <span class="keyword">let</span> headSprite = head.<span class="property">value</span>
            headSprite.<span class="property">position</span> = <span class="type">CGPoint</span>(x: headSprite.<span class="property">position</span>.<span class="property">x</span>-<span class="type">CGFloat</span>(deltaTime)*speed, y: headSprite.<span class="property">position</span>.<span class="property">y</span>)
            <span class="keyword">var</span> node = linkedBackgrounds.<span class="property">first</span>
            <span class="keyword">while</span> node?.<span class="property">next</span> != <span class="keyword">nil</span> {
                <span class="keyword">let</span> previous = node
                node = node?.<span class="property">next</span>
                node?.<span class="property">value</span>.<span class="property">position</span> = <span class="type">CGPoint</span>(x: (previous?.<span class="property">value</span>.<span class="property">position</span>.<span class="property">x</span>)!+(previous?.<span class="property">value</span>.<span class="property">frame</span>.<span class="property">width</span>)!,
                                               y: (previous?.<span class="property">value</span>.<span class="property">position</span>.<span class="property">y</span>)!)
            }
            <span class="keyword">if</span> <span class="call">spriteIsOutOfBounds</span>(sprite: head.<span class="property">value</span>) {
                <span class="keyword">let</span> node = linkedBackgrounds.<span class="call">remove</span>(node: head)
                linkedBackgrounds.<span class="call">append</span>(value: node)
            }
        }
    } <span class="keyword">else</span> {
        <span class="keyword">if let</span> tail = linkedBackgrounds.<span class="property">last</span> {
            <span class="keyword">let</span> tailSprite = tail.<span class="property">value</span>
            tailSprite.<span class="property">position</span> = <span class="type">CGPoint</span>(x: tailSprite.<span class="property">position</span>.<span class="property">x</span>+<span class="type">CGFloat</span>(deltaTime)*speed, y: tailSprite.<span class="property">position</span>.<span class="property">y</span>)
            <span class="keyword">var</span> node = linkedBackgrounds.<span class="property">last</span>
            <span class="keyword">while</span> node?.<span class="property">previous</span> != <span class="keyword">nil</span> {
                <span class="keyword">let</span> next = node
                node = node?.<span class="property">previous</span>
                node?.<span class="property">value</span>.<span class="property">position</span> = <span class="type">CGPoint</span>(x: (next?.<span class="property">value</span>.<span class="property">position</span>.<span class="property">x</span>)!-(node?.<span class="property">value</span>.<span class="property">frame</span>.<span class="property">width</span>)!,
                                               y: (next?.<span class="property">value</span>.<span class="property">position</span>.<span class="property">y</span>)!)
            }
            <span class="keyword">if</span> <span class="call">spriteIsOutOfBounds</span>(sprite: tail.<span class="property">value</span>) {
                <span class="keyword">let</span> node = linkedBackgrounds.<span class="call">remove</span>(node: tail)
                linkedBackgrounds.<span class="call">appendBeginning</span>(value: node)
            }
        }
    }
}

</code></pre><p>Maybe we could optimize this function, but for now it's ok.</p><p>You have the code <a href="https://github.com/pablogsIO/pablogsIO.github.io/tree/master/sourcecode/spritekit/BackgroundScrollPartTwo">here</a>. Hope you enjoy it!</p><p>And that's all folks!! See you in part three!!!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://pablogs.io/blog/2019-05-10-Spritekit-BackgroundScroll</guid><title>Spritekit - Background Scrolling - I</title><description>There are a lot of games using Infinite-Scrolling-Background technique to simulate characters movement.I</description><link>https://pablogs.io/blog/2019-05-10-Spritekit-BackgroundScroll</link><pubDate>Fri, 10 May 2019 08:00:00 +0200</pubDate><content:encoded><![CDATA[<p>There are a lot of games using Infinite-Scrolling-Background technique to simulate characters movement. The character is always on the same place in the screen and the background (buildings, trees, clouds...) moves toward left or right, depending on whether the character is moving to the right or to the left. We have this image:</p><p align="center">
  <img width="400" src="https://pablogs.io/images/posts/spritekit/backgroundscroll/bg.png">
</p><p>With this technique we'd have something like this:</p><p align="center">
  <img width="400" src="https://pablogs.io/images/posts/spritekit/backgroundscroll/background.gif">
</p><p>But, how could we achieve something like that? Do we have to have an infinite image? The solution is very simple. Have a look at this gif:</p><p align="center">
  <img width="400" src="https://pablogs.io/images/posts/spritekit/backgroundscroll/bgscroll.gif">
</p><p>In this gif, we have simulated the screen (lines in red) and four consecutives backgrounds (white, blue, red and green), when a background get off the screen we put it at the end and so on. Easy, isn't it?</p><h3>First approach</h3><p>I have created BackgroundScroll class to achieve this (bear in mind that positions are relative to the left red line)</p><pre><code>

<span class="keyword">import</span> SpriteKit

<span class="keyword">class</span> BackgroundScroll {

    <span class="keyword">private let</span> backgrounds: [<span class="type">SKSpriteNode</span>]
    <span class="keyword">private unowned let</span> scene: <span class="type">SKScene</span>
    <span class="keyword">private let</span> speed: <span class="type">CGFloat</span> = <span class="number">25</span>
    <span class="keyword">private var</span> totalWidth: <span class="type">CGFloat</span> = <span class="number">0</span>

    <span class="keyword">init</span>?(backgrounds: [<span class="type">SKSpriteNode</span>], scene: <span class="type">SKScene</span>){
        <span class="keyword">guard</span> backgrounds.<span class="property">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> {
            <span class="call">print</span>(<span class="string">"You have to include at least two backgrounds"</span>)
            <span class="keyword">return nil</span>
        }
        <span class="keyword">self</span>.<span class="property">scene</span> = scene
        <span class="keyword">self</span>.<span class="property">backgrounds</span> = backgrounds
        <span class="call">addBackgroundsToSceneAndCalculateTotalWidth</span>()

    }

    <span class="keyword">private func</span> addBackgroundsToSceneAndCalculateTotalWidth() {

        <span class="keyword">for</span> background <span class="keyword">in</span> backgrounds {
            <span class="keyword">self</span>.<span class="property">scene</span>.<span class="call">addChild</span>(background)
            totalWidth+=background.<span class="property">frame</span>.<span class="property">width</span>
        }
    }

    <span class="keyword">public func</span> scrollRight() {
        <span class="keyword">var</span> offset: <span class="type">CGFloat</span> = <span class="number">0</span>
        <span class="keyword">var</span> spaceToBeOutsideScene: <span class="type">CGFloat</span> = <span class="number">0</span>
        <span class="keyword">let</span> xOrigin = <span class="keyword">self</span>.<span class="property">scene</span>.<span class="property">frame</span>.<span class="property">width</span>/<span class="number">2</span>

        <span class="keyword">for</span> node <span class="keyword">in</span> backgrounds {
            spaceToBeOutsideScene += node.<span class="property">frame</span>.<span class="property">width</span>
            node.<span class="property">position</span> = <span class="type">CGPoint</span>(x: xOrigin+offset+node.<span class="property">frame</span>.<span class="property">width</span>/<span class="number">2</span>, y: <span class="keyword">self</span>.<span class="property">scene</span>.<span class="property">frame</span>.<span class="property">height</span>/<span class="number">2</span>)
            <span class="keyword">let</span> actionMoveOutsideScene = <span class="type">SKAction</span>.<span class="call">moveTo</span>(x: xOrigin-node.<span class="property">frame</span>.<span class="property">width</span>/<span class="number">2</span>, duration: <span class="type">TimeInterval</span>(spaceToBeOutsideScene/speed))
            <span class="keyword">let</span> actionMoveRightToLeft = <span class="type">SKAction</span>.<span class="call">moveTo</span>(x: xOrigin-node.<span class="property">frame</span>.<span class="property">width</span>/<span class="number">2</span>, duration: <span class="type">TimeInterval</span>((totalWidth)/speed))
            <span class="keyword">let</span> actionMoveToLastPosition = <span class="type">SKAction</span>.<span class="call">moveTo</span>(x: xOrigin+totalWidth-node.<span class="property">frame</span>.<span class="property">width</span>/<span class="number">2</span>, duration: <span class="number">0</span>)
            offset += node.<span class="property">size</span>.<span class="property">width</span>
            node.<span class="call">run</span>(<span class="type">SKAction</span>.<span class="call">sequence</span>([actionMoveOutsideScene, <span class="type">SKAction</span>.<span class="call">repeatForever</span>(<span class="type">SKAction</span>.<span class="call">sequence</span>([actionMoveToLastPosition,actionMoveRightToLeft]))]))
        }
    }

}

</code></pre><p>What we have done is to create SKActions to move the backgrounds from right toward left.</p><h3>Second approach</h3><p>There is another way of doing this. We are going to update the backgrounds positions every single time the update function in MainScene is called. We'll use a double linkedlist for that. Each cycle, we’ll update the head node position, the next node position will be relative to the previous one and so on.</p><pre><code>

<span class="keyword">class</span> BackgroundScroll {

    <span class="keyword">private let</span> backgrounds: [<span class="type">SKSpriteNode</span>]
    <span class="keyword">private var</span> linkedBackgrounds = <span class="type">LinkedList</span>&lt;<span class="type">SKSpriteNode</span>&gt;()

    <span class="keyword">private unowned let</span> scene: <span class="type">SKScene</span>
    <span class="keyword">private let</span> speed: <span class="type">CGFloat</span> = <span class="number">25</span>
    <span class="keyword">private var</span> totalWidth: <span class="type">CGFloat</span> = <span class="number">0</span>

    <span class="keyword">init</span>?(sprites: [<span class="type">SKSpriteNode</span>], scene: <span class="type">SKScene</span>, implementation: <span class="type">Implementation</span>) {
        <span class="keyword">guard</span> sprites.<span class="property">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> {
            <span class="call">print</span>(<span class="string">"You have to include at least two backgrounds"</span>)
            <span class="keyword">return nil</span>
        }
        <span class="keyword">self</span>.<span class="property">scene</span> = scene
        <span class="keyword">self</span>.<span class="property">backgrounds</span> = sprites
        <span class="keyword">switch</span> implementation {
        <span class="keyword">case</span> .<span class="dotAccess">actions</span>:
            <span class="call">addBackgroundsToSceneAndCalculateTotalWidth</span>()
        <span class="keyword">case</span> .<span class="dotAccess">linkedlist</span>:
            <span class="call">createLinkedList</span>()
        }
    }

    <span class="keyword">private func</span> addBackgroundsToSceneAndCalculateTotalWidth() {

        <span class="keyword">for</span> background <span class="keyword">in</span> backgrounds {
            <span class="keyword">self</span>.<span class="property">scene</span>.<span class="call">addChild</span>(background)
            totalWidth+=background.<span class="property">frame</span>.<span class="property">width</span>
        }
    }

    <span class="keyword">private func</span> createLinkedList() {
        <span class="keyword">var</span> offset: <span class="type">CGFloat</span> = <span class="number">0</span>
        <span class="keyword">let</span> xOrigin = <span class="keyword">self</span>.<span class="property">scene</span>.<span class="property">frame</span>.<span class="property">width</span>/<span class="number">2</span>

        <span class="keyword">for</span> sprite <span class="keyword">in</span> backgrounds {
            sprite.<span class="property">position</span> = <span class="type">CGPoint</span>(x: xOrigin+offset+sprite.<span class="property">frame</span>.<span class="property">width</span>/<span class="number">2</span>, y: <span class="keyword">self</span>.<span class="property">scene</span>.<span class="property">frame</span>.<span class="property">height</span>/<span class="number">2</span>)
            linkedBackgrounds.<span class="call">append</span>(value: sprite)
            <span class="keyword">self</span>.<span class="property">scene</span>.<span class="call">addChild</span>(sprite)
            offset += sprite.<span class="property">size</span>.<span class="property">width</span>
        }
    }

    <span class="keyword">public func</span> scrollRight() {
        <span class="keyword">var</span> offset: <span class="type">CGFloat</span> = <span class="number">0</span>
        <span class="keyword">var</span> spaceToBeOutsideScene: <span class="type">CGFloat</span> = <span class="number">0</span>
        <span class="keyword">let</span> xOrigin = <span class="keyword">self</span>.<span class="property">scene</span>.<span class="property">frame</span>.<span class="property">width</span>/<span class="number">2</span>

        <span class="keyword">for</span> node <span class="keyword">in</span> backgrounds {
            spaceToBeOutsideScene += node.<span class="property">frame</span>.<span class="property">width</span>
            node.<span class="property">position</span> = <span class="type">CGPoint</span>(x: xOrigin+offset+node.<span class="property">frame</span>.<span class="property">width</span>/<span class="number">2</span>, y: <span class="keyword">self</span>.<span class="property">scene</span>.<span class="property">frame</span>.<span class="property">height</span>/<span class="number">2</span>)
            <span class="keyword">let</span> actionMoveOutsideScene = <span class="type">SKAction</span>.<span class="call">moveTo</span>(x: xOrigin-node.<span class="property">frame</span>.<span class="property">width</span>/<span class="number">2</span>,
                                                         duration: <span class="type">TimeInterval</span>(spaceToBeOutsideScene/speed))
            <span class="keyword">let</span> actionMoveRightToLeft = <span class="type">SKAction</span>.<span class="call">moveTo</span>(x: xOrigin-node.<span class="property">frame</span>.<span class="property">width</span>/<span class="number">2</span>,
                                                        duration: <span class="type">TimeInterval</span>((totalWidth)/speed))
            <span class="keyword">let</span> actionMoveToLastPosition = <span class="type">SKAction</span>.<span class="call">moveTo</span>(x: xOrigin+totalWidth-node.<span class="property">frame</span>.<span class="property">width</span>/<span class="number">2</span>, duration: <span class="number">0</span>)
            offset += node.<span class="property">size</span>.<span class="property">width</span>
            node.<span class="call">run</span>(<span class="type">SKAction</span>.<span class="call">sequence</span>([actionMoveOutsideScene, <span class="type">SKAction</span>.<span class="call">repeatForever</span>(<span class="type">SKAction</span>.<span class="call">sequence</span>([actionMoveToLastPosition, actionMoveRightToLeft]))]))
        }
    }

    <span class="keyword">public func</span> update(deltaTime: <span class="type">TimeInterval</span>) {

        <span class="keyword">guard</span> !linkedBackgrounds.<span class="property">isEmpty</span> <span class="keyword">else</span> {
            <span class="keyword">return</span>
        }

        <span class="keyword">if let</span> head = linkedBackgrounds.<span class="property">first</span> {
            <span class="keyword">let</span> headSprite = head.<span class="property">value</span>
            headSprite.<span class="property">position</span> = <span class="type">CGPoint</span>(x: headSprite.<span class="property">position</span>.<span class="property">x</span>-<span class="type">CGFloat</span>(deltaTime)*speed, y: headSprite.<span class="property">position</span>.<span class="property">y</span>)
            <span class="keyword">var</span> node = linkedBackgrounds.<span class="property">first</span>
            <span class="keyword">while</span> node?.<span class="property">next</span> != <span class="keyword">nil</span> {
                <span class="keyword">let</span> previous = node
                node = node?.<span class="property">next</span>
                node?.<span class="property">value</span>.<span class="property">position</span> = <span class="type">CGPoint</span>(x: (previous?.<span class="property">value</span>.<span class="property">position</span>.<span class="property">x</span>)!+(previous?.<span class="property">value</span>.<span class="property">frame</span>.<span class="property">width</span>)!,
                                               y: (previous?.<span class="property">value</span>.<span class="property">position</span>.<span class="property">y</span>)!)
            }
            <span class="keyword">if</span> <span class="call">spriteIsOutOfBounds</span>(sprite: head.<span class="property">value</span>) {
                <span class="keyword">let</span> node = linkedBackgrounds.<span class="call">remove</span>(node: head)
                linkedBackgrounds.<span class="call">append</span>(value: node)
            }
        }

    }

    <span class="keyword">private func</span> spriteIsOutOfBounds(sprite: <span class="type">SKSpriteNode</span>) -&gt; <span class="type">Bool</span> {

        <span class="keyword">let</span> origin = <span class="keyword">self</span>.<span class="property">scene</span>.<span class="property">frame</span>.<span class="property">width</span>/<span class="number">2</span>

        <span class="keyword">let</span> outOfBounds = (sprite.<span class="property">position</span>.<span class="property">x</span>+sprite.<span class="property">frame</span>.<span class="property">width</span>/<span class="number">2</span>)&lt;origin

        <span class="keyword">return</span> outOfBounds
    }
}


</code></pre><p>You have the code <a href="https://github.com/pablogsIO/pablogsIO.github.io/tree/master/sourcecode/spritekit/BackgroundScroll">here</a>. Hope you enjoy it!</p><p>And that's all folks!! See you in part <a href="https://pablogs.io/2019/06/30/Spritekit-BackgroundScrollPartTwo.html">two</a>!!!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://pablogs.io/blog/2019-04-21-ParsingJSONFiles</guid><title>Parsing JSON files - Codable, A new hope</title><description>For a long time, I've been using...</description><link>https://pablogs.io/blog/2019-04-21-ParsingJSONFiles</link><pubDate>Sun, 21 Apr 2019 08:00:00 +0200</pubDate><content:encoded><![CDATA[<p>For a long time, I've been using <a href="https://github.com/SwiftyJSON/SwiftyJSON">swiftyjson</a> for parsing JSON files. It's a great library and if you, at some point, have had to work with JSON files, I'm pretty sure you've used it, am I right?</p><p>But Apple in 2017 gave us an easy way to work with JSON files: <strong>Codable</strong>. Codable is a typealias for <strong>Decodable</strong> and <strong>Encodable</strong> protocols.</p><h3>Simple data</h3><p>Let's see it in action. This will be our JSON file, a music album information:</p><pre><code>

{
 <span class="string">"name"</span>: <span class="string">"Love Over Gold"</span>,
 <span class="string">"label"</span>: <span class="string">"Warner Bros"</span>,
 <span class="string">"releaseDate"</span>: <span class="string">"1982-09-20T19:00:00Z"</span>
}

</code></pre><p>And this will be our representation in Swift of the JSON structure</p><pre><code>

<span class="keyword">struct</span> Album: <span class="type">Codable</span> {
    <span class="keyword">let</span> name: <span class="type">String</span>
    <span class="keyword">let</span> label: <span class="type">String</span>
    <span class="keyword">let</span> releaseDate: <span class="type">Date</span>
}

</code></pre><p>Album struct adopt the Codable protocol for encoding and decodign it.</p><pre><code>

<span class="keyword">import</span> Foundation

<span class="keyword">let</span> json = <span class="string">"""
{
 "name": "Love Over Gold",
 "label": "Warner Bros",
 "releaseDate": "1982-09-20T19:00:00Z"
}
"""</span>.<span class="call">data</span>(using: .<span class="dotAccess">utf8</span>)!


<span class="keyword">struct</span> Album: <span class="type">Codable</span> {
    <span class="keyword">let</span> name: <span class="type">String</span>
    <span class="keyword">let</span> label: <span class="type">String</span>
    <span class="keyword">let</span> releaseDate: <span class="type">Date</span>
}

<span class="comment">//Select our decoder and set the date decoding strategy to iso8601(https://en.wikipedia.org/wiki/ISO_8601)
//The decoder will do the conversion between the JSON and our Swift structure</span>
<span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()

decoder.<span class="property">dateDecodingStrategy</span> = .<span class="dotAccess">iso8601</span>

<span class="keyword">let</span> album = <span class="keyword">try</span> decoder.<span class="call">decode</span>(<span class="type">Album</span>.<span class="keyword">self</span>, from: json)

<span class="call">print</span>(album)

</code></pre><p>And the result is....</p><pre><code>

<span class="type">Album</span>(name: <span class="string">"Love Over Gold"</span>, label: <span class="string">"Warner Bros"</span>, releaseDate: <span class="number">1982</span>-<span class="number">09</span>-<span class="number">20 19</span>:<span class="number">00</span>:<span class="number">00</span> +<span class="number">0000</span>)

</code></pre><p>What have just happened here?</p><p>The Codable protocol, which is actually not one protocol, but two, Decodable and Encodable</p><pre><code>

<span class="keyword">public typealias</span> Codable = <span class="type">Decodable</span> &amp; <span class="type">Encodable</span>

<span class="keyword">public protocol</span> Encodable {
    <span class="keyword">public func</span> encode(to encoder: <span class="type">Encoder</span>) <span class="keyword">throws</span>
}

<span class="keyword">public protocol</span> Decodable {
    <span class="keyword">public init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span>
}

</code></pre><p>The <a href="https://developer.apple.com/documentation/swift/decodable">Decodable</a> protocol say that we have to implement the init function, but we didn't. So why this example has worked? because the Swift compiler has provided one for us, isn't it cute?</p><h3>Complex data</h3><p>Let's complicate a little bit our JSON file.</p><pre><code>

{
<span class="string">"band"</span>: <span class="string">"Dire Straits"</span>,
<span class="string">"album"</span>: {
    <span class="string">"name"</span>: <span class="string">"Love Over Gold"</span>,
    <span class="string">"label"</span>: <span class="string">"Warner Bros"</span>,
    <span class="string">"releaseDate"</span>: <span class="string">"1982-09-20T19:00:00Z"</span>
    },
<span class="string">"url"</span>: <span class="string">"https://www.markknopfler.com"</span>
}

</code></pre><p>We have added the name of the band and the url. Decoding is pretty easy:</p><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">let</span> json = <span class="string">"""
{
"band": "Dire Straits",
"album": {
    "name": "Love Over Gold",
    "label": "Warner Bros",
    "releaseDate": "1982-09-20T19:00:00Z"
    },
"band_url": "https://www.markknopfler.com"
}
"""</span>.<span class="call">data</span>(using: .<span class="dotAccess">utf8</span>)!
</code></pre><pre><code>

<span class="keyword">struct</span> Album: <span class="type">Codable</span> {
    <span class="keyword">let</span> name: <span class="type">String</span>
    <span class="keyword">let</span> label: <span class="type">String</span>
    <span class="keyword">let</span> releaseDate: <span class="type">Date</span>
}
<span class="keyword">struct</span> Band: <span class="type">Codable</span> {
    <span class="keyword">let</span> band: <span class="type">String</span>
    <span class="keyword">let</span> album: <span class="type">Album</span>
    <span class="keyword">let</span> band_url: <span class="type">URL</span>
}

<span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()
decoder.<span class="property">dateDecodingStrategy</span> = .<span class="dotAccess">iso8601</span>

<span class="keyword">let</span> band = <span class="keyword">try</span> decoder.<span class="call">decode</span>(<span class="type">Band</span>.<span class="keyword">self</span>, from: json)

<span class="call">print</span>(band)

</code></pre><p><strong>Result</strong>:</p><pre><code>

<span class="type">Band</span>(band: <span class="string">"Dire Straits"</span>, album: __lldb_expr_29.<span class="type">Album</span>(name: <span class="string">"Love Over Gold"</span>, label: <span class="string">"Warner Bros"</span>, releaseDate: <span class="number">1982</span>-<span class="number">09</span>-<span class="number">20 19</span>:<span class="number">00</span>:<span class="number">00</span> +<span class="number">0000</span>), url: https://www.<span class="property">markknopfler</span>.<span class="property">com</span>)

</code></pre><h3>Properties customization</h3><p>There's one more thing that the compiler generated for us, and that is a private enum called CodingKeys. This enum adopt the <a href="https://developer.apple.com/documentation/swift/codingkey">CodingKey</a> protocol and is used by the decoder for encoding/decoding, if a property is not defined in this enum, will be ignored.</p><pre><code>

<span class="keyword">private enum</span> CodingKeys: <span class="type">String</span>, <span class="type">CodingKey</span> {
  <span class="keyword">case</span> band
  <span class="keyword">case</span> album
  <span class="keyword">case</span> band_url
}

</code></pre><p>The <strong>band_url</strong> property doesn't match the Swift naming convention, so let's do something about it. We will state that bandUrl property match with band_url.</p><pre><code>

<span class="keyword">struct</span> Band: <span class="type">Codable</span> {
    <span class="keyword">let</span> band: <span class="type">String</span>
    <span class="keyword">let</span> album: <span class="type">Album</span>
    <span class="keyword">let</span> bandUrl: <span class="type">URL</span>

    <span class="keyword">private enum</span> CodingKeys: <span class="type">String</span>, <span class="type">CodingKey</span> {
        <span class="keyword">case</span> band
        <span class="keyword">case</span> album
        <span class="keyword">case</span> bandUrl = <span class="string">"band_url"</span>
    }
}

</code></pre><h3>Decodable customization</h3><p>We have customized our properties, now, we're going to customize the decodable by implementing init from decoder.</p><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">let</span> json = <span class="string">"""
{
"band": "Dire Straits",
"album": {
    "name": "Love Over Gold",
    "label": "Warner Bros",
    "releaseDate": "1982-09-20T21:00:00Z"
    },
"band_url": "https://www.markknopfler.com"
}
"""</span>.<span class="call">data</span>(using: .<span class="dotAccess">utf8</span>)!
</code></pre><pre><code><span class="keyword">struct</span> Album: <span class="type">Codable</span> {
    <span class="keyword">let</span> name: <span class="type">String</span>
    <span class="keyword">let</span> label: <span class="type">String</span>
    <span class="keyword">let</span> releaseDate: <span class="type">Date</span>
}
<span class="keyword">struct</span> Band: <span class="type">Codable</span> {
    <span class="keyword">let</span> band: <span class="type">String</span>
    <span class="keyword">let</span> album: <span class="type">Album</span>
    <span class="keyword">let</span> bandUrl: <span class="type">URL</span>

    <span class="keyword">private enum</span> CodingKeys: <span class="type">String</span>, <span class="type">CodingKey</span> {
        <span class="keyword">case</span> band
        <span class="keyword">case</span> album
        <span class="keyword">case</span> bandUrl = <span class="string">"band_url"</span>
    }

    <span class="keyword">public init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> {
        <span class="keyword">let</span> container = <span class="keyword">try</span> decoder.<span class="call">container</span>(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)
        band = <span class="keyword">try</span> container.<span class="call">decode</span>(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .<span class="dotAccess">band</span>)
        album = <span class="keyword">try</span> container.<span class="call">decode</span>(<span class="type">Album</span>.<span class="keyword">self</span>, forKey: .<span class="dotAccess">album</span>)
        bandUrl = <span class="keyword">try</span> container.<span class="call">decode</span>(<span class="type">URL</span>.<span class="keyword">self</span>, forKey: .<span class="dotAccess">bandUrl</span>)
    }
}

<span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()
decoder.<span class="property">dateDecodingStrategy</span> = .<span class="dotAccess">iso8601</span>

<span class="keyword">let</span> band = <span class="keyword">try</span> decoder.<span class="call">decode</span>(<span class="type">Band</span>.<span class="keyword">self</span>, from: json)

<span class="call">print</span>(band)

</code></pre><pre><code>

<span class="type">Band</span>(band: <span class="string">"Dire Straits"</span>, album: __lldb_expr_19.<span class="type">Album</span>(name: <span class="string">"Love Over Gold"</span>, label: <span class="string">"Warner Bros"</span>, releaseDate: <span class="number">1982</span>-<span class="number">09</span>-<span class="number">20 21</span>:<span class="number">00</span>:<span class="number">00</span> +<span class="number">0000</span>), bandUrl: https://www.<span class="property">markknopfler</span>.<span class="property">com</span>)

</code></pre><h3>Conclusion</h3><p>I think this is a pretty step forward and we should give Codable a try.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://pablogs.io/blog/2019-03-31-MapClusteringIII</guid><title>Quadtree and Map Clustering - III</title><description>In the previous post we viewed how to cluster annotations. Now, let see it in a real map.</description><link>https://pablogs.io/blog/2019-03-31-MapClusteringIII</link><pubDate>Sun, 31 Mar 2019 08:00:00 +0200</pubDate><content:encoded><![CDATA[<p>In the previous <a href="https://pablogs.io/2019/02/06/MapClusteringII.html">post</a> we viewed how to cluster annotations. Now, let see it in a real map.</p><p>Remember this image?</p><p align="center">
  <img width="300" src="https://pablogs.io/images/posts/clustering/iPhone.png">
</p><p>Pretty overwhelming for the user, isn't it? We will try to get something like this.</p><p align="center">
  <img width="300" src="https://pablogs.io/images/posts/clustering/clusterAnnotations.png">
</p><p>The philosophy behind this image is the same as the previous posts. We have to create a QuadTree and ask this QuadTree for annotations in different regions of the visible map.</p><p>QuadTree class is pretty similar to the one that we used.</p><p>ClusterManager class will need to know the visible map region and the zoom level of the map for clustering annotations.</p><p>Depending on the zoom level, we will divide the map region in cells of different size and we will use this cells to ask the QuadTree for annotations inside these cells.</p><pre><code>

<span class="keyword">class func</span> cellSizeForZoomScale(zoomScale: <span class="type">MKZoomScale</span>) -&gt; <span class="type">Int</span> {

    <span class="keyword">let</span> zoomLevel = <span class="call">zoomScaleToZoomLevel</span>(scale: zoomScale)

    <span class="keyword">switch</span> zoomLevel {
    <span class="keyword">case</span> <span class="number">0</span>...<span class="number">4</span>:
        <span class="keyword">return</span> <span class="number">32</span>
    <span class="keyword">case</span> <span class="number">5</span>...<span class="number">8</span>:
        <span class="keyword">return</span> <span class="number">16</span>
    <span class="keyword">case</span> <span class="number">9</span>...<span class="number">16</span>:
        <span class="keyword">return</span> <span class="number">8</span>
    <span class="keyword">case</span> <span class="number">17</span>...<span class="number">20</span>:
        <span class="keyword">return</span> <span class="number">4</span>
    <span class="keyword">default</span>:
        <span class="keyword">return</span> <span class="number">10</span>
    }
}

</code></pre><p>The function clusterAnnotationWithinMapRectangle will do...</p><ul><li>Calculate de size of the cell</li><li>Ask the QuadTree for annotations</li><li>Display annotations on the map.</li></ul><pre><code>

<span class="keyword">public func</span> clusterAnnotationWithinMapRectangle(visibleMapRect: <span class="type">MKMapRect</span>, zoomScale: <span class="type">Double</span>) {

        <span class="keyword">guard</span> !zoomScale.<span class="property">isInfinite</span> <span class="keyword">else</span> {
            <span class="keyword">return</span>
        }
        <span class="keyword">var</span> clusterAnnotations = [<span class="type">MKAnnotation</span>]()
        <span class="keyword">let</span> cellSizePoints = <span class="type">Double</span>(visibleMapRect.<span class="property">size</span>.<span class="property">width</span>/<span class="type">Double</span>(<span class="type">PGClusteringManager</span>.<span class="call">cellSizeForZoomScale</span>(zoomScale: <span class="type">MKZoomScale</span>(zoomScale))))
        <span class="keyword">let</span> minX = visibleMapRect.<span class="property">minX</span>
        <span class="keyword">let</span> maxX = visibleMapRect.<span class="property">maxX</span>
        <span class="keyword">let</span> minY = visibleMapRect.<span class="property">minY</span>
        <span class="keyword">let</span> maxY = visibleMapRect.<span class="property">maxY</span>

        operationQueue.<span class="call">cancelAllOperations</span>()
        operationQueue.<span class="call">addOperation</span> {

            <span class="keyword">var</span> yCoordinate = minY

            <span class="keyword">while</span> yCoordinate&lt;<span class="call">maxY</span> {
                <span class="keyword">var</span> xCoordinate = minX

                <span class="keyword">while</span> xCoordinate&lt;<span class="call">maxX</span> {
                    <span class="keyword">let</span> area = <span class="type">PGBoundingBox</span>.<span class="call">mapRectToBoundingBox</span>(mapRect: <span class="type">MKMapRect</span>(x: xCoordinate, y: yCoordinate, width: cellSizePoints, height: cellSizePoints))
                    <span class="keyword">self</span>.<span class="property">quadTree</span>.<span class="call">queryRegion</span>(searchInBoundingBox: area) { (annotations) <span class="keyword">in

                        if</span> annotations.<span class="property">count</span>&gt;<span class="number">1</span> {
                            <span class="keyword">var</span> totalX = <span class="number">0.0</span>
                            <span class="keyword">var</span> totalY = <span class="number">0.0</span>

                            <span class="keyword">for</span> annotation <span class="keyword">in</span> annotations {
                                totalX += annotation.<span class="property">coordinate</span>.<span class="property">latitude</span>
                                totalY += annotation.<span class="property">coordinate</span>.<span class="property">longitude</span>
                            }
                            <span class="keyword">let</span> totalAnnotations = annotations.<span class="property">count</span>

                            clusterAnnotations.<span class="call">append</span>(<span class="type">PGAnnotation</span>(coordinate: <span class="type">CLLocationCoordinate2D</span>(latitude: totalX/<span class="type">Double</span>(totalAnnotations), longitude: totalY/<span class="type">Double</span>(totalAnnotations)), title: <span class="string">"</span>\(annotations.<span class="property">count</span>)<span class="string">"</span>, subtitle: <span class="string">"Clustered"</span>))
                        } <span class="keyword">else if</span> annotations.<span class="property">count</span> == <span class="number">1</span> {
                            clusterAnnotations.<span class="call">append</span>(annotations.<span class="property">first</span>!)
                        }
                    }
                    xCoordinate+=cellSizePoints
                }
                yCoordinate+=cellSizePoints
            }
            <span class="keyword">self</span>.<span class="property">delegate</span>?.<span class="call">displayAnnotations</span>(annotations: clusterAnnotations)
        }
    }
</code></pre><p>And that's it. You have an example <a href=" https://github.com/pablogsIO/PGClustering">here</a></p><p>Enjoy!!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://pablogs.io/blog/2019-02-06-MapClusteringII</guid><title>Quadtree and Map Clustering - II</title><description>In the previous post we viewed how to build a QuadTree, now we are going to do the real magic...</description><link>https://pablogs.io/blog/2019-02-06-MapClusteringII</link><pubDate>Wed, 6 Feb 2019 08:00:00 +0100</pubDate><content:encoded><![CDATA[<p>In the previous <a href="https://pablogs.io/2019/01/23/MapClusteringI.html">post</a> we viewed how to build a QuadTree, now we are going to do the real magic...</p><h2>Clustering</h2><p>Clustering is the task of grouping a set of objects in such a way that objects in the same group (called a cluster) are more similar (in some sense, i.e. distance) to each other than to those in other groups (clusters). We’ll need to find all the points which lie in different regions of the map to create groups of points.</p><pre><code>

<span class="keyword">struct</span> ClusterPoint {
    <span class="keyword">let</span> origin: <span class="type">CGPoint</span>
    <span class="keyword">let</span> points: <span class="type">Int</span>
}

<span class="keyword">class</span> PGClusteringManager {

    <span class="keyword">private let</span> quadtree: <span class="type">QuadTree</span>
    <span class="keyword">private let</span> boxWidth = <span class="type">CGFloat</span>(<span class="number">5.0</span>)
    <span class="keyword">private let</span> boxHeight = <span class="type">CGFloat</span>(<span class="number">10.0</span>)

    <span class="keyword">init</span>(quadtree: <span class="type">QuadTree</span>) {
        <span class="keyword">self</span>.<span class="property">quadtree</span> = quadtree
    }

    <span class="keyword">public func</span> clusterAnnotationsWithinRectangle(rectangle: <span class="type">CGRect</span>) -&gt; [<span class="type">ClusterPoint</span>] {

        <span class="keyword">var</span> clusters = [<span class="type">ClusterPoint</span>]()

        <span class="keyword">let</span> boxArea = <span class="call">calculateBoxAreaSize</span>(size: rectangle.<span class="property">size</span>)
        <span class="keyword">var</span> xCoordinate = rectangle.<span class="property">origin</span>.<span class="property">x</span>
        <span class="keyword">var</span> yCoordinate = rectangle.<span class="property">origin</span>.<span class="property">y</span>

        <span class="keyword">while</span> yCoordinate&lt;rectangle.<span class="property">size</span>.<span class="call">height</span> {
            xCoordinate = rectangle.<span class="property">origin</span>.<span class="property">x</span>
            <span class="keyword">while</span> xCoordinate&lt;rectangle.<span class="property">size</span>.<span class="call">width</span> {
                <span class="keyword">let</span> boundingBox = <span class="type">CGRect</span>(x: xCoordinate, y: yCoordinate, width: boxArea.<span class="property">width</span>, height: boxArea.<span class="property">height</span>)
                quadtree.<span class="call">queryRegion</span>(rectangle: boundingBox) { (points) <span class="keyword">in
                    if</span> points.<span class="property">count</span> != <span class="number">0</span> {
                        <span class="keyword">var</span> totalX = <span class="type">CGFloat</span>(<span class="number">0</span>)
                        <span class="keyword">var</span> totalY = <span class="type">CGFloat</span>(<span class="number">0</span>)

                        <span class="keyword">for</span> point <span class="keyword">in</span> points {
                            totalX += point.<span class="property">x</span>
                            totalY += point.<span class="property">y</span>
                        }
                        <span class="keyword">let</span> totalPoints = <span class="type">CGFloat</span>(points.<span class="property">count</span>)
                        clusters.<span class="call">append</span>(<span class="type">ClusterPoint</span>(origin: <span class="type">CGPoint</span>(x: totalX/totalPoints,
                                                                     y: totalY/totalPoints),
                                                     points: points.<span class="property">count</span>))
                    }
                }
                xCoordinate += boxArea.<span class="property">width</span>
            }
            yCoordinate += boxArea.<span class="property">height</span>
        }

        <span class="keyword">return</span> clusters
    }

    <span class="keyword">private func</span> calculateBoxAreaSize(size: <span class="type">CGSize</span>) -&gt; <span class="type">CGSize</span> {

        <span class="keyword">let</span> width = size.<span class="property">width</span>/boxWidth
        <span class="keyword">let</span> height = size.<span class="property">height</span>/boxHeight

        <span class="keyword">return</span> <span class="type">CGSize</span>(width: width, height: height)

    }

}


</code></pre><p>After insert all data in the QuadTree and calling the clusterAnnotationsWithinRectangle function, we'll get something like this:</p><p align="center">
  <img width="500" src="https://pablogs.io/images/posts/clustering/clustering.png">
</p><p>Awesome!! And now, we are going to check that everything is ok. In the next gift we can see all the points and cluster with their bounding box.</p><p align="center">
  <img width="500" src="https://pablogs.io/images/posts/clustering/clustering.gif">
</p>]]></content:encoded></item><item><guid isPermaLink="true">https://pablogs.io/blog/2019-01-23-MapClusteringI</guid><title>Quadtree and Map Clustering - I</title><description>Nowadays, lot of apps use maps to show some information, great apps like...</description><link>https://pablogs.io/blog/2019-01-23-MapClusteringI</link><pubDate>Wed, 23 Jan 2019 08:00:00 +0100</pubDate><content:encoded><![CDATA[<p>Nowadays, lot of apps use maps to show some information, great apps like <a href="https://itunes.apple.com/es/app/coffee-near-me/id683874335?mt=8">Starbucks Near Me</a>, <a href="https://itunes.apple.com/bz/app/luas-dublin/id1257004479?l=en&mt=8">Luas Dublin</a> etc. But, what happen if there are a lot of annotations to show? probably we'd face up something like this.</p><p align="center">
  <img width="300" src="https://pablogs.io/images/posts/clustering/iPhone.png">
</p><p>Really annoying, isn't it? This map is crowded and it's very difficult to get significant information from it.</p><p>One way to solve this problem is by grouping points that are at a certain distance from each other on the screen. At a low zoom levels (like the image shown above) we'll show a few groups of points and at a high zoom levels more groups.</p><p align="center">
  <img width="300" src="https://pablogs.io/images/posts/clustering/low.png">
  <img width="300" src="https://pablogs.io/images/posts/clustering/high.png">
</p><p>This technique is called <strong>Clustering</strong>. Clustering is the task of grouping a set of objects in such a way that objects in the same group (called a cluster) are more similar (in some sense, i.e. distance) to each other than to those in other groups (clusters).</p><p>Basically this is a search problem, we'll need to find all the points which lie in different regions of the map to create groups of points. QuadTree is a data structure that can efficiently find all locations contained in a specific region. It's built by recursively subdividing a two-dimensional space into smaller regions.</p><h3>QuadTree</h3><p>Each node of the QuadTree will have a list of points (in that node), the capacity and a bounding box. When we insert a new point in the QuadTree, first we check if the node's bounding box contains the coordinates of the new point, if so, we check if the node is full. If not, we can insert the point, but if the node is full, we have to divide it in four small nodes and try to insert the point in each of this child nodes.</p><pre><code>

<span class="keyword">class</span> QuadTree {

    <span class="keyword">static let</span> capacity = <span class="number">4</span>

    <span class="keyword">var</span> points = [<span class="type">CGPoint</span>]()
    <span class="keyword">var</span> boundingBox = <span class="type">CGRect</span>()
    <span class="keyword">var</span> isDivided = <span class="keyword">false

    private var</span> northWest: <span class="type">QuadTree</span>?
    <span class="keyword">private var</span> northEast: <span class="type">QuadTree</span>?
    <span class="keyword">private var</span> southWest: <span class="type">QuadTree</span>?
    <span class="keyword">private var</span> southEast: <span class="type">QuadTree</span>?

    <span class="keyword">init</span>(boundingBox: <span class="type">CGRect</span>) {
        <span class="keyword">self</span>.<span class="property">boundingBox</span> = boundingBox
    }

    <span class="keyword">public func</span> insertPoint(newPoint: <span class="type">CGPoint</span>) {

        <span class="keyword">guard self</span>.<span class="property">boundingBox</span>.<span class="call">contains</span>(newPoint) <span class="keyword">else</span> {
            <span class="keyword">return</span>
        }
        <span class="keyword">if</span> points.<span class="property">count</span> &lt; <span class="type">QuadTree</span>.<span class="property">capacity</span> &amp;&amp; northWest == <span class="keyword">nil</span> {
            points.<span class="call">append</span>(newPoint)
        } <span class="keyword">else</span> {
            <span class="keyword">if</span> northWest == <span class="keyword">nil</span> {
                <span class="keyword">self</span>.<span class="call">subdivide</span>()
            }
            northWest?.<span class="call">insertPoint</span>(newPoint: newPoint)
            northEast?.<span class="call">insertPoint</span>(newPoint: newPoint)
            southWest?.<span class="call">insertPoint</span>(newPoint: newPoint)
            southEast?.<span class="call">insertPoint</span>(newPoint: newPoint)
        }
    }
    <span class="keyword">private func</span> subdivide() {
        <span class="keyword">self</span>.<span class="property">isDivided</span> = <span class="keyword">true
        let</span> width = <span class="keyword">self</span>.<span class="property">boundingBox</span>.<span class="property">width</span>/<span class="number">2</span>
        <span class="keyword">let</span> height = <span class="keyword">self</span>.<span class="property">boundingBox</span>.<span class="property">height</span>/<span class="number">2</span>
        <span class="keyword">let</span> size = <span class="type">CGSize</span>(width: width-offset, height: height-offset)

        <span class="keyword">self</span>.<span class="property">northWest</span> = <span class="type">QuadTree</span>(boundingBox: <span class="type">CGRect</span>(origin: <span class="type">CGPoint</span>(x: <span class="keyword">self</span>.<span class="property">boundingBox</span>.<span class="property">origin</span>.<span class="property">x</span>,
                                                                      y: <span class="keyword">self</span>.<span class="property">boundingBox</span>.<span class="property">origin</span>.<span class="property">y</span>),
                                                      size: size))
        <span class="keyword">self</span>.<span class="property">northEast</span> = <span class="type">QuadTree</span>(boundingBox: <span class="type">CGRect</span>(origin: <span class="type">CGPoint</span>(x: <span class="keyword">self</span>.<span class="property">boundingBox</span>.<span class="property">origin</span>.<span class="property">x</span>+width,
                                                                      y: <span class="keyword">self</span>.<span class="property">boundingBox</span>.<span class="property">origin</span>.<span class="property">y</span>),
                                                      size: size))
        <span class="keyword">self</span>.<span class="property">southWest</span> = <span class="type">QuadTree</span>(boundingBox: <span class="type">CGRect</span>(origin: <span class="type">CGPoint</span>(x: <span class="keyword">self</span>.<span class="property">boundingBox</span>.<span class="property">origin</span>.<span class="property">x</span>,
                                                                      y: <span class="keyword">self</span>.<span class="property">boundingBox</span>.<span class="property">origin</span>.<span class="property">y</span>+height),
                                                      size: size))
        <span class="keyword">self</span>.<span class="property">southEast</span> = <span class="type">QuadTree</span>(boundingBox: <span class="type">CGRect</span>(origin: <span class="type">CGPoint</span>(x: <span class="keyword">self</span>.<span class="property">boundingBox</span>.<span class="property">origin</span>.<span class="property">x</span>+width,
                                                                      y: <span class="keyword">self</span>.<span class="property">boundingBox</span>.<span class="property">origin</span>.<span class="property">y</span>+height),
                                                      size: size))
    }
  }


</code></pre><p>Here you can see my QuadTree in action.</p><p align="center">
  <img width="500" src="https://pablogs.io/images/posts/clustering/quadtreeinsertion.gif">

</p><p>See you in Quadtree and Map Clustering - II</p>]]></content:encoded></item><item><guid isPermaLink="true">https://pablogs.io/blog/2018-12-31-TutorialCollectionInsideTableView</guid><title>Tutorial - UICollectionView inside TableViewCell</title><description>And here we are, last hours of 2018 and I'm writing the last post of the year, hope you like it.</description><link>https://pablogs.io/blog/2018-12-31-TutorialCollectionInsideTableView</link><pubDate>Mon, 31 Dec 2018 08:00:00 +0100</pubDate><content:encoded><![CDATA[<p>And here we are, last hours of 2018 and I'm writing the last post of the year, hope you like it.</p><p>Throughout this tutorial I'll try to explain how to insert an UICollectionView in a TableViewCell. Each TableViewCell will have the name of the band and a CollectionView with the members of the band. I am assuming that you have read this <a href="https://pablogs.io/2018/11/30/TutorialTableViewXIB.html">post</a>. Here is the result</p><p align="center">
  <img width="400" src="https://pablogs.io/images/posts/collectiontableview/result.png">
</p><h3>Create the project</h3><ul><li>Open Xcode and create a Single View App.</li><li>First of all we are going to create our model (we have created createModel() function to populate data).</li></ul><pre><code><span class="keyword">struct</span> Band {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> image: <span class="type">UIImageView</span>
    <span class="keyword">var</span> members: [<span class="type">String</span>]
}
</code></pre><ul><li>Open Main.storyboard file</li><li>Drag and drop an UITableView</li><li>Drag and drop an UITableViewCell</li><li>Select the Main.storyboard file and press Show assistant editor button.</li><li>Create the tableView IBOutlet in your ViewController</li></ul><h3>Create XIB file</h3><ul><li>Create a new User interface file. File-&gt; New File and name it BandCell.</li></ul><p align="center">
  <img width="600" src="https://pablogs.io/images/posts/customcells/step5.png">
</p><ul><li>Drop an UITableViewCell</li></ul><p align="center">
  <img width="600" src="https://pablogs.io/images/posts/customcells/step6.png">
</p><ul><li>Insert a UILabel (rock band name) and a UICollectionView (for members of the band) at the right of the UILabel</li></ul><p align="center">
  <img width="600" src="https://pablogs.io/images/posts/collectiontableview/step9.png">
</p><h3>Create the BandCell class</h3><ul><li>Create a new Cocoa Touch class and name it BandCell</li><li>In the BandCell.xib file<ul><li>open the Identity Inspector tab and in custom class type <strong>BandCell</strong>.</li><li>open the Attribute inspector tab and in Identifier type <strong>BandCellId</strong></li></ul></li></ul><p align="center">
  <img width="300" src="https://pablogs.io/images/posts/customcells/step7.png">
  <img width="300" src="https://pablogs.io/images/posts/customcells/step8.png">
</p><ul><li>Create IBOutlets in BandCell class for UILabel and UICollectionView</li></ul><p align="center">
  <img width="800" src="https://pablogs.io/images/posts/collectiontableview/step10.png">
</p><pre><code><span class="keyword">@IBOutlet weak var</span> bandName: <span class="type">UILabel</span>!
<span class="keyword">@IBOutlet weak var</span> collectionView: <span class="type">UICollectionView</span>!
  ```


- <span class="type">Add</span> a function to configure the data

</code></pre><p>swift public func configureCell(band: Band) { self.bandName.text = band.name self.members = band.members }</p><pre><code>


### <span class="type">Configure</span> tableView, and tableview's delegate and datasource

- <span class="type">Register</span> the <span class="type">BandCell</span> nib and create <span class="type">UITableViewDataSource</span> functions


</code></pre><p>swift override func viewDidLoad() { super.viewDidLoad() tableView.delegate = self tableView.dataSource = self tableView.register(UINib.init(nibName: "BandCell", bundle: nil), forCellReuseIdentifier: "BandCellId") tableView.tableFooterView = UIView() }</p><pre><code>


</code></pre><p>swift extension ViewController: UITableViewDataSource { func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return model.count }</p><p>func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {</p><p>let cell = tableView.dequeueReusableCell(withIdentifier: "BandCellId") as! BandCell</p><p>cell.configureCell(band: model[indexPath.row])</p><p>return cell } }</p><pre><code>

### <span class="type">Configure</span> collectionView, and collectionView's datasource

<span class="type">Now</span> it's time <span class="keyword">for</span> our collectionView. <span class="type">In</span> our <span class="type">BandCell</span> <span class="keyword">class</span> we have an <span class="type">UICollectionView</span> and we have to <span class="keyword">do</span> the same process <span class="keyword">as</span> we did with our tableView. <span class="type">We</span> are going to create a <span class="type">MembersCVCell</span>.<span class="property">swift</span> and a <span class="type">MembersCVCell</span>.<span class="property">xib</span>.

- <span class="type">MembersCVCell</span>.<span class="property">xib</span> will have a <span class="type">UILabel</span>
- <span class="type">MembersCVCell</span>.<span class="property">swift</span> will extend <span class="type">UICollectionViewCell</span> and an <span class="type">IBOutlet</span>, just like this

</code></pre><p>swift class MembersCVCell: UICollectionViewCell {</p><p>@IBOutlet weak var bandMember: UILabel!</p><p>func configureCell(bandMember: String) { self.bandMember.text = bandMember }</p><p>}</p><pre><code>- <span class="type">In BandCell</span>.<span class="property">swift</span> we have to setup the collectionView and <span class="type">UICollectionViewDataSource</span> functions

</code></pre><p>swift override func awakeFromNib() { super.awakeFromNib() self.collectionView.register(UINib(nibName: "MembersCVCell", bundle: nil), forCellWithReuseIdentifier: "MembersId") collectionView.delegate = self collectionView.dataSource = self }</p><pre><code>
</code></pre><p>swift extension BandCell: UICollectionViewDelegate, UICollectionViewDataSource { func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int { return members.count }</p><p>func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell { let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "MembersId", for: indexPath) as! MembersCVCell</p><p>cell.configureCell(bandMember: members[indexPath.row])</p><p>return cell }</p><p>}</p><pre><code><span class="type">And</span> thats all. <span class="type">Pretty</span> easy, isn't it? here <span class="keyword">is</span> the [code](/images/posts/collectiontableview/<span class="type">CollectionInsideTable</span>.<span class="property">zip</span>)

### <span class="type">Merry Christmas</span> and <span class="type">Happy New Year</span>
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://pablogs.io/blog/2018-11-30-TutorialTableViewXIB</guid><title>Tutorial - Custom Cells with XIB</title><description>In this tutorial I'm going to explain how to create custom cells with xibs files in a few easy steps.</description><link>https://pablogs.io/blog/2018-11-30-TutorialTableViewXIB</link><pubDate>Fri, 30 Nov 2018 08:00:00 +0100</pubDate><content:encoded><![CDATA[<p>In this tutorial I'm going to explain how to create custom cells with xibs files in a few easy steps.</p><h3>Create the project</h3><ul><li>Open Xcode and create a Single View App.</li><li>Open Main.storyboard file</li><li>Drag and drop an UITableView</li><li>Drag and drop an UITableViewCell</li></ul><p align="center">
  <img width="600" src="https://pablogs.io/images/posts/customcells/step1.png">
  <img width="600" src="https://pablogs.io/images/posts/customcells/step2.png">
</p><h3>Connect the UITableView with the ViewController</h3><ul><li>Select the Main.storyboard file and press Show assistant editor button. You will have something like this</li></ul><p align="center">
  <img width="600" src="https://pablogs.io/images/posts/customcells/step3.png">
</p><ul><li>Create the tableView IBOutlet in your ViewController</li></ul><p align="center">
  <img width="600" src="https://pablogs.io/images/posts/customcells/step4.png">
</p><h3>Create XIB file</h3><ul><li>Create a new User interface file. File-&gt; New File and name it BandCell.</li></ul><p align="center">
  <img width="600" src="https://pablogs.io/images/posts/customcells/step5.png">
</p><ul><li>Drop an UITableViewCell</li></ul><p align="center">
  <img width="600" src="https://pablogs.io/images/posts/customcells/step6.png">
</p><ul><li>Insert two UILabels like this</li></ul><p align="center">
  <img width="600" src="https://pablogs.io/images/posts/customcells/step9.png">
</p><h3>Create the BandCell class</h3><ul><li>Create a new Cocoa Touch class and name it BandCell</li><li>In the BandCell.xib file<ul><li>open the Identity Inspector tab and in custom class type <strong>BandCell</strong>.</li><li>open the Attribute inspector tab and in Identifier type <strong>BandCellId</strong></li></ul></li></ul><p align="center">
  <img width="300" src="https://pablogs.io/images/posts/customcells/step7.png">
  <img width="300" src="https://pablogs.io/images/posts/customcells/step8.png">
</p><ul><li>Create an IBOutlet in BandCell class</li></ul><p align="center">
  <img width="800" src="https://pablogs.io/images/posts/customcells/step10.png">
</p><pre><code>     <span class="keyword">@IBOutlet weak var</span> rockBandName: <span class="type">UILabel</span>!
  ```


- <span class="type">Add</span> a function to configure the data

</code></pre><p>swift public func configureCell(name: String) { rockBandName.text = name }</p><pre><code>


### <span class="type">Configure</span> tableView, and tableview's delegate and datasource

<span class="type">Once</span> we have configured everything, we are ready to <span class="keyword">do</span> the <span class="keyword">final</span> step.

- <span class="type">Register</span> the <span class="type">BandCell</span> nib and add a few data <span class="keyword">for</span> our tableView


</code></pre><p>swift private var data = ["Dire Straits", "AC/DC", "Joe Satriani", "Bruce Springsteen", "Julian Lage", "Menilmontant Swing", "Pink Floyd"]</p><p>override func viewDidLoad() { super.viewDidLoad() tableView.delegate = self tableView.dataSource = self tableView.register(UINib.init(nibName: "BandCell", bundle: nil), forCellReuseIdentifier: "BandCellId") }</p><pre><code>


</code></pre><p>swift extension ViewController: UITableViewDataSource { func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return data.count }</p><p>func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: "BandCellId") as! BandCell</p><p>cell.configureCell(name: data[indexPath.row])</p><p>return cell }</p><p>} extension ViewController: UITableViewDelegate {</p><p>}</p><pre><code>

<span class="type">And</span> thats all. <span class="type">If</span> you run the project something like this will appear


&lt;p align=<span class="string">"center"</span>&gt;
  &lt;img width=<span class="string">"400"</span> src=<span class="string">"/images/posts/customcells/final.png"</span>&gt;
&lt;
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://pablogs.io/blog/2018-10-31-Level%20Indicators</guid><title>Level Indicators</title><description>I have no idea about design, but I think I can appreciate beautiful ones. And that's what happened when I saw...</description><link>https://pablogs.io/blog/2018-10-31-Level%20Indicators</link><pubDate>Wed, 31 Oct 2018 08:00:00 +0100</pubDate><content:encoded><![CDATA[<p>I have no idea about design, but I think I can appreciate beautiful ones. And that's what happened when I saw <a href="https://www.instagram.com/uxmobile/">UX mobile instagram account</a> ... and I felt in love with this one:</p><p align="center">
  <img width="400" src="https://pablogs.io/images/posts/indicator.png">
</p><p>So I decided to do a swift control, and here is the result.</p><p align="center">
  <img width="400" src="https://pablogs.io/images/posts/pglevelindicator.gif">
</p><p>You have a fully functional example at my <a href="https://github.com/pablogsIO/PGLevelIndicator">Github</a></p><p>It's very easy to use:</p><ul><li>Create an array of parameters:</li></ul><pre><code><span class="keyword">let</span> parameters = [<span class="type">ItemParameters</span>(title: <span class="string">"nO2 Band"</span>, titleColor: <span class="type">UIColor</span>.<span class="property">purple</span>, level: .<span class="dotAccess">low</span>), <span class="type">ItemParameters</span>(title: <span class="string">"o3 Band"</span>, titleColor: <span class="type">UIColor</span>.<span class="property">yellow</span>, level: .<span class="dotAccess">medium</span>), <span class="type">ItemParameters</span>(title: <span class="string">"pM10 Band"</span>, titleColor: <span class="type">UIColor</span>.<span class="property">green</span>, level: .<span class="dotAccess">high</span>), <span class="type">ItemParameters</span>(title: <span class="string">"pM25 Band"</span>, titleColor: <span class="type">UIColor</span>.<span class="property">orange</span>, level: .<span class="dotAccess">low</span>)]

</code></pre><p>(The level parameter is not used, but maybe in future revisions we will use it)</p><ul><li>Create the PGLevelIndicator object:</li></ul><pre><code><span class="keyword">let</span> levelIndicator = <span class="type">PGLevelIndicator</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">100</span>, width: <span class="keyword">self</span>.<span class="property">view</span>.<span class="property">frame</span>.<span class="property">size</span>.<span class="property">width</span>, height: <span class="keyword">self</span>.<span class="property">view</span>.<span class="property">frame</span>.<span class="property">size</span>.<span class="property">width</span>), itemsParameters: parameters)

</code></pre><ul><li>And finally, add to the main view</li></ul><pre><code><span class="keyword">self</span>.<span class="property">view</span>.<span class="call">addSubview</span>(levelIndicator!)
</code></pre><p>Thanks for reading!!!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://pablogs.io/blog/2018-09-23-Fun%20with%20Enums</guid><title>Fun with enums (Fun with flags)</title><description>Swift enums are pretty awesome. For a person like me, whose first programming language was C (a long, long, long time ago), it's like a breath of fresh air.</description><link>https://pablogs.io/blog/2018-09-23-Fun%20with%20Enums</link><pubDate>Sun, 23 Sep 2018 08:00:00 +0200</pubDate><content:encoded><![CDATA[<h2>Fun with Enums - API Endpoint</h2><p>Swift enums are pretty awesome. For a person like me, whose first programming language was C (a long, long, long time ago), it's like a breath of fresh air.</p><p>Enums are first-class types and can adopt features traditionally supported only by classes:</p><ul><li>Conform to protocols</li><li>Computed properties</li><li>Instance methods</li><li>Initializers</li></ul><h3>Basic Enums</h3><p>Let's start with a classic example</p><pre><code><span class="keyword">enum</span> Guitar {
  <span class="keyword">case</span> classical
  <span class="keyword">case</span> electric
  <span class="keyword">case</span> acoustic
 }
</code></pre><h3>Associated values</h3><p>Associated values are a perfect way to add additional information to enums. Imagine for instance that you would like to add some information to our enum example. A guitar has a serial number. An electric guitar could have one, two or more pickups, an acoustic guitar could be electrified or not and so on. Let's translate this into code.</p><pre><code><span class="keyword">enum</span> Guitar {
    <span class="keyword">case</span> classical(serialNumber: <span class="type">String</span>)
    <span class="keyword">case</span> electric(serialNumber: <span class="type">String</span>, pickups: <span class="type">Int</span>)
    <span class="keyword">case</span> acoustic(serialNumber: <span class="type">String</span>, electrified: <span class="type">Bool</span>)
}

<span class="keyword">let</span> classicalGuitar = <span class="type">Guitar</span>.<span class="call">classical</span>(serialNumber: <span class="string">"SW87234"</span>)
<span class="keyword">let</span> electricGuitar = <span class="type">Guitar</span>.<span class="call">electric</span>(serialNumber: <span class="string">"HG0983"</span>, pickups: <span class="number">2</span>)
<span class="keyword">let</span> acousticGuitar = <span class="type">Guitar</span>.<span class="call">acoustic</span>(serialNumber: <span class="string">"JJ8888"</span>, electrified: <span class="keyword">false</span>)

<span class="keyword">if case let</span> <span class="type">Guitar</span>.<span class="call">acoustic</span>(serialNumber, electrified) = acousticGuitar {

    <span class="call">print</span>(<span class="string">"Acoustic guitar. Serial number</span>\(serialNumber)<span class="string">. Electrified:</span> \(electrified)<span class="string">"</span>)
}
</code></pre><p><strong>Output</strong>:</p><pre><code>  <span class="type">Acoustic</span> guitar. <span class="type">Serial</span> numberJJ8888. <span class="type">Electrified</span>: <span class="keyword">false</span>
</code></pre><h3>Enums and protocols</h3><p>For example, we could model API Endpoints with enums. What we would like to do is build different endpoints based on our needs. Take the <a href="https://api.tfl.gov.uk/">TFL Unified API</a> for instance. To retrieve lines status for a few lines (victoria, piccadilly and central), we'd have to build something like this https://api.tfl.gov.uk//Line/victoria,piccadilly,central/Status</p><p>Wouldn't it be great if, with a simple line of code, we could get this url? That's pretty cool but you will say...Ooh great!....show me the code!!! Ok, let's do it.</p><p>We define a protocol with a url variable</p><pre><code><span class="keyword">protocol</span> EndPointProtocol {
    <span class="keyword">var</span> url: <span class="type">URL</span> { <span class="keyword">get</span> }
}
</code></pre><pre><code><span class="keyword">enum</span> LineEndPoint {
    <span class="keyword">case</span> validmodes
    <span class="keyword">case</span> lineStatus([<span class="type">String</span>])
}
</code></pre><pre><code><span class="keyword">extension</span> <span class="type">LineEndPoint</span>: <span class="type">EndPointProtocol</span> {

    <span class="keyword">var</span> url: <span class="type">URL</span> {

        <span class="keyword">guard var</span> url = <span class="type">URLComponents</span>(string: <span class="string">"https://api.tfl.gov.uk"</span>) <span class="keyword">else</span> { <span class="call">fatalError</span>(<span class="string">"Error"</span>) }

        <span class="keyword">switch self</span> {
        <span class="keyword">case</span> .<span class="dotAccess">validmodes</span>:
            url.<span class="property">path</span> = <span class="string">"/Line/Meta/Modes"</span>
        <span class="keyword">case</span> .<span class="dotAccess">lineStatus</span>(<span class="keyword">let</span> idLines):
            <span class="keyword">let</span> linesIdcommaseparated = <span class="call">getCommaSeparated</span>(array: idLines)
            url.<span class="property">path</span> = <span class="string">"/Line/</span>\(linesIdcommaseparated)<span class="string">/Status"</span>
        }

        <span class="keyword">let</span> urlFinal = url.<span class="property">url</span>

        <span class="keyword">return</span> urlFinal!
    }

    <span class="keyword">private func</span> getCommaSeparated(array: [<span class="type">String</span>]) -&gt; <span class="type">String</span> {
        <span class="keyword">return</span> array.<span class="call">map</span> { <span class="type">String</span>($0)}.<span class="call">joined</span>(separator: <span class="string">","</span>)
    }
}

</code></pre><p>The only thing we have to do is:</p><pre><code>

<span class="keyword">let</span> lineStatus = <span class="type">LineEndPoint</span>.<span class="call">lineStatus</span>([<span class="string">"victoria"</span>,<span class="string">"piccadilly"</span>,<span class="string">"central"</span>])

<span class="call">print</span>(<span class="string">"Line status endpoint:</span> \(lineStatus.<span class="property">url</span>)<span class="string">"</span>)
</code></pre><p><strong>Output</strong>:</p><pre><code><span class="type">Line</span> status endpoint: https://api.<span class="property">tfl</span>.<span class="property">gov</span>.<span class="property">uk</span>/<span class="type">Line</span>/victoria,piccadilly,central/<span class="type">Status</span>
</code></pre><p>And that's it. A fancy and elegant way of getting endpoints.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://pablogs.io/blog/2018-08-28-Create%20a%20pod%20in%20Cocoapods</guid><title>Create a Pod in Cocoapods</title><description>This is a simple guide to upload your first Pod to Cocoapods</description><link>https://pablogs.io/blog/2018-08-28-Create%20a%20pod%20in%20Cocoapods</link><pubDate>Tue, 28 Aug 2018 08:00:00 +0200</pubDate><content:encoded><![CDATA[<p>This is a simple guide to upload your first Pod to <a href="https://cocoapods.org">Cocoapods</a>.</p><p>CocoaPods is a dependency manager for Swift and Objective-C Cocoa projects and I'm sure that you have a lot of code you are proud of and would like to share with the world.</p><h3>First steps - Install CocoaPods</h3><pre><code>$ sudo gem install cocoapods
</code></pre><h3>Upload your code to GitHub</h3><p>Upload your code/project to github. <a href="https://github.com/pablogsIO/GeometricLoaders">Here</a> you can find an example of a library I uploaded to Cocoapods.</p><p align="center">
  <img width="600" src="https://pablogs.io/images/posts/cocoapod_1.png">
</p><ul><li>Source folder contains the source code of the library</li><li>GeometricLoaders folder contains a fully functional example of how GeometricLoaders works</li></ul><h3>Create podspec file</h3><p>A Pod has a podspec file that defines the specifications of a Pod. In this example we have the following podspec:</p><pre><code><span class="type">Pod</span>::<span class="type">Spec</span>.<span class="property">new</span> <span class="keyword">do</span> |s|
  s.<span class="property">name</span>         = <span class="string">"GeometricLoaders"</span>
  s.<span class="property">version</span>      = <span class="string">"1.1.0"</span>
  s.<span class="property">summary</span>      = <span class="string">"Fancy and beautiful loaders for you awesome apps!"</span>
  s.<span class="property">homepage</span>     = <span class="string">"https://github.com/pablogsIO/GeometricLoaders"</span>
  s.<span class="property">license</span>      = '<span class="type">MIT</span>'
  s.<span class="property">author</span>       = <span class="string">"Pablo Garcia"</span>
  s.<span class="property">source</span>       = { :git =&gt; <span class="string">"https://github.com/pablogsIO/GeometricLoaders.git"</span>, :tag =&gt; s.<span class="property">version</span> }
  s.<span class="property">screenshots</span>   = ['https://raw.<span class="property">githubusercontent</span>.<span class="property">com</span>/pablogsIO/<span class="type">GeometricLoaders</span>/master/<span class="type">Images</span>/infinityloader.<span class="property">gif</span>',
    'https://raw.<span class="property">githubusercontent</span>.<span class="property">com</span>/pablogsIO/<span class="type">GeometricLoaders</span>/master/<span class="type">Images</span>/blinkingcirclesLoader.<span class="property">gif</span>',
    'https://raw.<span class="property">githubusercontent</span>.<span class="property">com</span>/pablogsIO/<span class="type">GeometricLoaders</span>/master/<span class="type">Images</span>/circleLoader.<span class="property">gif</span>',
    'https://raw.<span class="property">githubusercontent</span>.<span class="property">com</span>/pablogsIO/<span class="type">GeometricLoaders</span>/master/<span class="type">Images</span>/circleinmotionloader.<span class="property">gif</span>',
    'https://raw.<span class="property">githubusercontent</span>.<span class="property">com</span>/pablogsIO/<span class="type">GeometricLoaders</span>/master/<span class="type">Images</span>/orbitloader.<span class="property">gif</span>',
    'https://raw.<span class="property">githubusercontent</span>.<span class="property">com</span>/pablogsIO/<span class="type">GeometricLoaders</span>/master/<span class="type">Images</span>/waterwaves.<span class="property">gif</span>']
  s.<span class="property">platform</span>     = :ios, '<span class="number">10.0</span>'
  s.<span class="property">source_files</span> = '<span class="type">Source</span>/*.swift'
  s.<span class="property">frameworks</span>   = '<span class="type">UIKit</span>'
  s.<span class="property">swift_version</span>= '<span class="number">4.0</span>'
  s.<span class="property">requires_arc</span> = <span class="keyword">true</span>
  s.<span class="property">social_media_url</span> = 'https://twitter.<span class="property">com</span>/_pablogs_'
end
</code></pre><ul><li>s.name: The name of the Pod.</li><li>s.version: The version of the Pod. CocoaPods follows semantic versioning. The version have to be equals to GitHub's release</li><li>s.summary: The description should be short, yet informative</li><li>s.homepage: The URL of the homepage of the Pod</li><li>s.license: The license of the Pod</li><li>s.author: This is you!</li><li>s.source_files: The location from where the library should be retrieved.</li><li>s.screenshots: A list of URLs to images showcasing the Pod.</li><li>s.platform: The platform on which this Pod is supported</li><li>s.frameworks: A list of system frameworks that the user’s target needs to link against.</li><li>s.swift_version: The version of Swift that the specification supports.</li><li>s.requires<em>arc: requires</em>arc allows you to specify which source_files use ARC</li><li>s.social<em>media</em>url: The URL for the social media contact of the Pod, CocoaPods web services can use this.</li></ul><p><a href="https://guides.cocoapods.org/syntax/podspec.html">Here</a> you can find more information about podspec file</p><h3>Upload podspec and create a release</h3><p>Once you have created podspec you have to create a release in Github.</p><p align="center">
  <img width="600" src="https://pablogs.io/images/posts/cocoapod_2.png">
</p><h3>Publishing your Pod</h3><p>Well done!!! we are pretty close to the end.</p><h4>Verifying your pod - Pod lib lint</h4><p>Before publish your pod we should verify that everything is correct.</p><p>Open a terminal and in your project folder type</p><pre><code>$&gt; pod lib lint
</code></pre><p>If everything is ok you should get something like this...</p><pre><code>

 -&gt; <span class="type">GeometricLoaders</span> (<span class="number">1.1.0</span>)

<span class="type">GeometricLoaders</span> passed validation.
</code></pre><h4>Create a CocoaPods account</h4><pre><code>pod trunk register &lt;<span class="type">Your Email</span>&gt;
</code></pre><p>For more information please visit <a href="https://guides.cocoapods.org/making/getting-setup-with-trunk.html">Getting setup with trunk</a></p><h4>Publish it!!!!</h4><pre><code>pod trunk push <span class="type">GeometricLoaders</span>.<span class="property">podspec</span>
</code></pre><p>And that's all folks!!!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://pablogs.io/blog/2018-07-09-Front%20Camera%20UIView</guid><title>Front Camera UIView</title><description>I’ve developed a FrontCameraView UIView class for a project that I’ve been working on</description><link>https://pablogs.io/blog/2018-07-09-Front%20Camera%20UIView</link><pubDate>Mon, 9 Jul 2018 08:00:00 +0200</pubDate><content:encoded><![CDATA[<p>I’ve developed a FrontCameraView UIView class for a project that I’ve been working on ( Don't you think Luis? ;) ). This project has allowed me the opportunity to study Apple’s AVFoundation framework.</p><p>According to Apple documentation:</p><p>The AVFoundation framework combines four major technology areas that together encompass a wide range of tasks for capturing, processing, synthesising, controlling, importing and exporting audiovisual media on Apple platforms.</p><p>The main features of FrontCameraView class are:</p><ul><li>Preview front camera</li><li>Move the preview UIView to every corner of the screen.</li><li>Record video</li></ul><h3>Configure camera and microphone permission</h3><p>First of all, we need to ask the user for permission to use the camera and microphone. That’s why we need to configure our Info.plist. Include the NSCameraUsageDescription and NSMicrophoneUsageDescription key in your app’s Info.plist file. For each key we have to provide a message that explains to the user why our app needs to capture media.</p><p>This message will appear the first time we run the app and usually the user accepts it. But, what happens if the user has revoked this permission? I think it’s a good idea to check out if our app still has permission to access the camera and microphone. If not, we could show a warning message to the user stating that and offering a solution.</p><p>With this line of code we will show a warning message and, if the user presses the Settings button, send him to the app’s configuration panel.</p><h3>CameraManager class</h3><p>This class manage camera permissions, access, configuration, preview and recording.</p><p>This class has the following public functions:</p><ul><li>previewFrontCamera</li><li>startRecording</li><li>stopRecording</li><li>cameraAuthorisation</li></ul><h3>FrontCameraView class</h3><p>This class shows the camera preview and allows the user to move the view to every corner of the screen and start and stop recording the camera preview.</p><p>This class has the following public functions:</p><ul><li>starPreview</li><li>stopPreview</li><li>startRecording</li><li>stopRecording</li></ul><h3>FrontCameraView in Action</h3><p align="center">
    <img width="200" src="https://pablogs.io/images/posts/duck.gif">
</p><p>You can download the full project with a fully functional example <a href="https://github.com/pablogsIO/FrontCameraView">here</a></p><p>And that’s it!! If you use it I’ll be happy to know about it.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://pablogs.io/blog/2018-06-12-CameraButton</guid><title>Camera Record Button</title><description>For a project that I've been working on, I decided to create a record button like the one in iOS.</description><link>https://pablogs.io/blog/2018-06-12-CameraButton</link><pubDate>Tue, 12 Jun 2018 08:00:00 +0200</pubDate><content:encoded><![CDATA[<p>For a project that I've been working on, I decided to create a record button like the one in iOS.</p><p>Here is the result.</p><p align="center">
  <img width="300" src="https://pablogs.io/images/posts/camera/recordbutton.gif">
</p><p>The source code is on <a href="https://github.com/pablogsIO/RecordButton/tree/master/Source">github</a></p><h4>Overriding the draw(_ rect: CGRect) function</h4><p>RecordButton extends UIView and overrides the draw(_ rect: CGRect) function. In this function, we draw the button and add a gesture recognizer to detect when the button is pressed. We also add an animation to transform the button from a round shape to a square.</p><h4>Delegate</h4><p>Classes that use RecordButton class should implement RecordButtonDelegate to know the button has been pressed.</p><pre><code><span class="keyword">protocol</span> RecordButtonDelegate: <span class="keyword">class</span> {

    <span class="keyword">func</span> tapButton(isRecording: <span class="type">Bool</span>)
}
</code></pre><h3>Usage</h3><h4>Interface Builder</h4><ul><li>Drag RecordButton class into your project</li><li>In your storyboard, select an UIView</li><li>Go the the identity inspector and in the class field, type RecordButton instead of UIView</li></ul><p align="center">
    <img width="800" src="https://pablogs.io/images/posts/camera/IBRecordButton.gif">
</p><h4>Manually</h4><ul><li>Drag RecordButton class into your project</li><li>In your ViewController add the following</li></ul><pre><code>     <span class="keyword">var</span> recordButton: <span class="type">RecordButton</span>?
    <span class="keyword">override func</span> viewDidAppear(<span class="keyword">_</span> animated: <span class="type">Bool</span>) {

        <span class="keyword">super</span>.<span class="call">viewDidAppear</span>(animated)

        <span class="keyword">let</span> recordButtonSide = <span class="keyword">self</span>.<span class="property">view</span>.<span class="property">bounds</span>.<span class="property">size</span>.<span class="property">height</span>/<span class="number">10</span>
        recordButton = <span class="type">RecordButton</span>(frame: <span class="type">CGRect</span>(x: <span class="keyword">self</span>.<span class="property">view</span>.<span class="property">bounds</span>.<span class="property">width</span>/<span class="number">2</span>-recordButtonSide/<span class="number">2</span>,
                                                  y: <span class="keyword">self</span>.<span class="property">view</span>.<span class="property">bounds</span>.<span class="property">height</span>/<span class="number">2</span>-recordButtonSide/<span class="number">2</span>,
                                                  width: recordButtonSide,
                                                  height: recordButtonSide))
        recordButton?.<span class="property">delegate</span> = <span class="keyword">self

        self</span>.<span class="property">view</span>.<span class="call">addSubview</span>(recordButton!)

    }
</code></pre><p>You can download the full project with a fully functional example <a href="https://github.com/pablogsIO/RecordButton">here</a></p><p>And that's it!! If you use it I'll be happy to know about it.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://pablogs.io/blog/2018-05-02-Geometric%20Loaders</guid><title>Geometric Loaders</title><description>Whenever I do a new app, I always search on the internet for new cool activity indicators.</description><link>https://pablogs.io/blog/2018-05-02-Geometric%20Loaders</link><pubDate>Wed, 2 May 2018 08:00:00 +0200</pubDate><content:encoded><![CDATA[<p>Whenever I do a new app, I always search on the internet for new cool activity indicators. Recently I've decided to create my own personal activity indicators.</p><p>Here you can see what I've made</p><p align="center">
  <img width="200" src="https://pablogs.io/images/posts/geometric/infinityloader.gif">
  <img width="200" src="https://pablogs.io/images/posts/geometric/orbitloader.gif">
  <img width="200" src="https://pablogs.io/images/posts/geometric/circleinmotionloader.gif">
  <img width="200" src="https://pablogs.io/images/posts/geometric/blinkingcirclesLoader.gif">
  <img width="200" src="https://pablogs.io/images/posts/geometric/circleLoader.gif">
  <img width="200" src="https://pablogs.io/images/posts/geometric/waterwaves.gif">
</p><p>You can download the source code <a href="https://github.com/pablogsIO/GeometricLoaders/tree/master/Source">here</a></p><p>GeometricLoaders has a main class called GeometricLoader.swift. This class extends UIView and is responsible for creating the loader view and setting the size and position of the main view. We use the static method createGeometricLoader() to initialize the loader.</p><pre><code><span class="keyword">open static func</span> createGeometricLoader() -&gt; <span class="type">Self</span> {

        <span class="keyword">let</span> loader = <span class="keyword">self</span>.<span class="keyword">init</span>()
        loader.<span class="call">setupView</span>()

        <span class="keyword">return</span> loader
    }
</code></pre><pre><code><span class="keyword">internal func</span> setupView() {

        <span class="keyword">guard let</span> window = <span class="type">UIApplication</span>.<span class="property">shared</span>.<span class="property">delegate</span>?.<span class="property">window</span> <span class="keyword">else</span> { <span class="keyword">return</span> }
        <span class="keyword">guard let</span> mainWindow = window <span class="keyword">else</span> {<span class="keyword">return</span>}

        <span class="keyword">self</span>.<span class="property">frame</span> = mainWindow.<span class="property">frame</span>
        <span class="keyword">self</span>.<span class="property">center</span> = <span class="type">CGPoint</span>(x: mainWindow.<span class="property">bounds</span>.<span class="property">midX</span>, y: mainWindow.<span class="property">bounds</span>.<span class="property">midY</span>)

        mainWindow.<span class="call">addSubview</span>(<span class="keyword">self</span>)

        <span class="keyword">self</span>.<span class="property">loaderSuperview</span> = mainWindow
        <span class="keyword">self</span>.<span class="property">loaderView</span>.<span class="property">frame</span> = <span class="type">CGRect</span>(x: frame.<span class="property">origin</span>.<span class="property">x</span>, y: frame.<span class="property">origin</span>.<span class="property">y</span>, width: frame.<span class="property">width</span>/<span class="number">2</span>, height: frame.<span class="property">width</span>/<span class="number">2</span>)
        <span class="keyword">self</span>.<span class="property">loaderView</span>.<span class="property">center</span> = <span class="type">CGPoint</span>(x: frame.<span class="property">width</span>/<span class="number">2</span>, y: frame.<span class="property">height</span>/<span class="number">2</span>)
        <span class="keyword">self</span>.<span class="property">loaderView</span>.<span class="property">backgroundColor</span> = <span class="type">UIColor</span>.<span class="property">clear</span>
        <span class="keyword">self</span>.<span class="property">isHidden</span> = <span class="keyword">true
        self</span>.<span class="call">addSubview</span>(loaderView)

    }
</code></pre><p>Loaders (Infinity, Orbit, CirclesInMotion...) extend the GeometricLoader class. Once the Loader is created, just call startAnimation() to start the loader animation.</p><pre><code><span class="keyword">func</span> startAnimation() {

        <span class="keyword">self</span>.<span class="call">configureLoader</span>()
        isHidden = <span class="keyword">false
        if</span> superview == <span class="keyword">nil</span> {
            loaderSuperview?.<span class="call">addSubview</span>(<span class="keyword">self</span>)
        }
    }
</code></pre><p>This method will configure the loader, add the loader elements to the layer of the loaderView and shows the loader's animation.</p><p>To stop the loader we call the stopAnimation() method.</p><pre><code><span class="keyword">func</span> stopAnimation() {

        <span class="keyword">self</span>.<span class="property">isHidden</span> = <span class="keyword">false
        self</span>.<span class="property">isAnimating</span> = <span class="keyword">false
        self</span>.<span class="call">removeFromSuperview</span>()
        <span class="keyword">self</span>.<span class="property">layer</span>.<span class="call">removeAllAnimations</span>()

    }
</code></pre><p>You can download the full project with a fully functional example <a href="https://github.com/pablogsIO/GeometricLoaders">here</a></p><p>And that's it!! If you use it I'll be happy to know about it.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://pablogs.io/blog/2018-04-12-TubeLineStops</guid><title>TubeLineStops</title><description>Hello and welcome to the first post of this humble blog!</description><link>https://pablogs.io/blog/2018-04-12-TubeLineStops</link><pubDate>Thu, 12 Apr 2018 08:00:00 +0200</pubDate><content:encoded><![CDATA[<p>Hello and welcome to the first post of this humble blog!</p><p>A few months ago I did the <a href="https://itunes.apple.com/bz/app/luas-dublin/id1257004479?l=en&mt=8">Luas Dublin app</a>. This app shows Luas lines and real-time information for each stop. What I would like to share with you today is a class that I used to draw Luas lines and stops. You can download a full example <a href="https://github.com/pablogsIO/TubeLineStops">here</a>.</p><p>The TubeLineStop class is an UIView subclass. This class draws parts of the line, these parts could be the beginning of the line, the end, forks etc. You can see different types here:</p><p align="center">
  <img width="200" src="https://pablogs.io/images/posts/tube/tailLeft.png">
  <img width="200" src="https://pablogs.io/images/posts/tube/tailForkedLefStoptDown.png">
  <img width="200" src="https://pablogs.io/images/posts/tube/unionRightStopUp.png">
  <img width="200" src="https://pablogs.io/images/posts/tube/middle.png">
  <img width="200" src="https://pablogs.io/images/posts/tube/forkLeftStopDown.png">
  <img width="200" src="https://pablogs.io/images/posts/tube/tailRight.png">
</p><p>You can configure the color of the line and the type of the stop that you are drawing.</p><p>The TubeLineStop class overwrite the draw function of the UIView class. To draw the line, the first thing that we have to do is to create a context with the function UIGraphicsBeginImageContext. According to Apple class reference, UIGraphicsBeginImageContext creates a bitmap-based graphics context and makes it the current context.</p><p>So, let's do it</p><pre><code><span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()
</code></pre><p>Once we have the context, we can draw lines, circles or whatever we want. For example, to draw the first stop of a line we could do something like this:</p><pre><code>context?.<span class="call">setLineWidth</span>(<span class="number">4.0</span>) (<span class="number">1</span>)
context?.<span class="call">setStrokeColor</span>(color) (<span class="number">2</span>)
context?.<span class="call">move</span>(to: <span class="type">CGPoint</span>(x: width/<span class="number">2</span>, y: yLinePosition)) (<span class="number">3</span>)
context?.<span class="call">addLine</span>(to: <span class="type">CGPoint</span>(x: width, y: yLinePosition)) (<span class="number">4</span>)
context?.<span class="call">strokePath</span>()(<span class="number">5</span>)
context?.<span class="call">addEllipse</span>(in: <span class="type">CGRect</span>(x: width/<span class="number">2</span>, y: yStopPosition, 
		   width: circleDiameter, height: circleDiameter)) (<span class="number">6</span>)
context?.<span class="call">fillPath</span>() (<span class="number">7</span>)
context?.<span class="call">strokePath</span>()
</code></pre><p>First, we have to set the line width (1) and the stroke colour (2). The next step is to move to the starting point of the line that is going to be drawn (3). With (4) we specified where the end of the line is. After that, having defined the line width, colour and path, we are ready to draw the line (5). To draw the tube stop, we must define the rectangular area into which the shape must fit and then call the addEllipse(in:) context method (6). With (7) we fill the path.</p><p>And that’s it! You can download the full project <a href="https://github.com/pablogsIO/TubeLineStops">here</a></p>]]></content:encoded></item></channel></rss>